package com.sky.service.impl;

import com.github.pagehelper.Page;
import com.github.pagehelper.PageHelper;
import com.sky.constant.MessageConstant;
import com.sky.constant.StatusConstant;
import com.sky.dto.DishDTO;
import com.sky.dto.DishPageQueryDTO;
import com.sky.entity.Dish;
import com.sky.entity.DishFlavor;
import com.sky.exception.DeletionNotAllowedException;
import com.sky.mapper.DishFlavorMapper;
import com.sky.mapper.DishMapper;
import com.sky.mapper.SetMealDishMapper;
import com.sky.result.PageResult;
import com.sky.service.DishService;
import com.sky.vo.DishVO;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;


@Service
@Slf4j
public class DishServiceImpl implements DishService {

    @Autowired
    private DishMapper dishMapper;
    @Autowired
    private DishFlavorMapper dishFlavorMapper;
    @Autowired
    private SetMealDishMapper setMealDishMapper;

    /**
     * add a new dish and relative flavor
     * @param dishDTO
     */
    @Transactional // this method refers to two sheets: dish and flavor. So it needs the @Transactional annotation, which can ensure consistency and integrity of data operations,
    // When multiple table operations are involved (e.g. the dish table and the flavor table), to ensure the consistency and integrity of the operations, these operations are typically placed within a transactional environment.
    // By using the @Transactional annotation, you can ensure that these operations either all succeed or all roll back, thereby avoiding data inconsistency issues.
    public void saveWithFlavor(DishDTO dishDTO) {

        log.info("save dish with flavor:{}", dishDTO);

        Dish dish = new Dish();
        BeanUtils.copyProperties(dishDTO,dish);

        // Insert a record into the dish table.
        dishMapper.insert(dish);

        // get the value of primary key generated by insert sentence in DishMapper.xml (useGeneratedKeys="true" keyProperty="id")
        Long dishId = dish.getId();

        List<DishFlavor> flavors = dishDTO.getFlavors();
        if(flavors != null && flavors.size() > 0){
            flavors.forEach(dishFlavor -> {
                dishFlavor.setDishId(dishId);
            });
            // Insert multiple records into the flavor table.
            dishFlavorMapper.insertBatch(flavors);
        }
    }


    /**
     * Dish page query
     * @param dishPageQueryDTO
     * @return
     */
    public PageResult pageQuery(DishPageQueryDTO dishPageQueryDTO) {
        PageHelper.startPage(dishPageQueryDTO.getPage(), dishPageQueryDTO.getPageSize());
        Page<DishVO> page = dishMapper.pageQuery(dishPageQueryDTO);
        return new PageResult(page.getTotal(),page.getResult());

    }

    /**
     * Batch deletion of dishes
     * @param ids
     */
    @Transactional
    public void deleteBatch(List<Long> ids){
        /**
         * Business Rules:
         * A dish can be deleted individually or in batches.
         * Dishes that are currently on sale cannot be deleted.
         * Dishes associated with a set meal cannot be deleted.
         * When a dish is deleted, its related flavor data must also be deleted.
         */

        // Check if current dish can be deleted -- Are there any dishes currently on sale (status)?
        // 1. Get every dish by id; 2. Check these dishes' status; 3. Throw exception if dishes cannot be deleted (on sale).
        for(Long id : ids){
            Dish dish = dishMapper.getById(id);
            if(dish.getStatus() == StatusConstant.ENABLE){
                // Dishes that are currently on sale cannot be deleted.
                throw new DeletionNotAllowedException(MessageConstant.DISH_ON_SALE);
            }
        }

        // Check if current dish can be deleted -- Is it associated with a set meal?
        List<Long> setMealIds = setMealDishMapper.getSetMealIdsByDishIds(ids);
        if(setMealIds != null && setMealIds.size() > 0){
            //Dishes associated with a set meal cannot be deleted.
            throw new DeletionNotAllowedException(MessageConstant.DISH_BE_RELATED_BY_SETMEAL);
        }

        // Delete the dish data from the dish table.
        // This for loop code is possible to generate so many sql sentences, so it can be Optimised.
        /*for(Long id : ids){
            dishMapper.deleteById(id);
            // Delete the flavor data associated with the dish. - no need to check if this dish has relative flavor, delete it anyway
            dishFlavorMapper.deleteByDishId(id);
        }*/

        // delete batch dish records by dish id collection
        // sql: delete from dish where id in (?,?,?)
        dishMapper.deleteByIds(ids);

        // delete batch relative flavor records by dish id collection
        // sql: delete from dish_flavor where dish_id in (?,?,?)
        dishFlavorMapper.deleteByDishIds(ids);
    }

    /**
     * Enquiry dish by id
     * @param id
     * @return
     */
    @Transactional
    public DishVO getByIdWithFlavor(Long id){
        // Get dish record by id
        Dish dish = dishMapper.getById(id);
        // Get flavor record by dish_id
        List<DishFlavor> dishFlavors = dishFlavorMapper.getByDishId(id);
        // Encapsulate dish record and flavor record into DishVO Object
        DishVO dishVO = new DishVO();
        BeanUtils.copyProperties(dish, dishVO);
        dishVO.setFlavors(dishFlavors);

        return dishVO;
    }

    /**
     * update the dish basic attributions' value and relative flavor attributions' value
     * @param dishDTO
     */
    public void updateWithFlavor(DishDTO dishDTO){
        Dish dish = new Dish();
        BeanUtils.copyProperties(dishDTO,dish);

        // update the dish basic attributions' value
        dishMapper.update(dish);

        // delete original flavor records
        dishFlavorMapper.deleteByDishId(dishDTO.getId());

        // insert flavor records again
        List<DishFlavor> flavors = dishDTO.getFlavors();
        if(flavors != null && flavors.size() > 0){
            flavors.forEach(dishFlavor -> {
                dishFlavor.setDishId(dishDTO.getId());
            });
            // Insert multiple records into the flavor table.
            dishFlavorMapper.insertBatch(flavors);
        }

    }


}

















